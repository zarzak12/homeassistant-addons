#!/command/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# Home Assistant Community Add-on: Example
# Example init script, runs before any other service
# ==============================================================================

# ğŸ“¦ Installer les dÃ©pendances
nginx

# ğŸ” DÃ©chiffrer client_id et client_secret en Base64
client_id=$(echo -n "ODRlZGRmNDgtMmI4ZS0xMWU1LWIyYTUtMTI0Y2ZhYjI1NTk1XzQ3NWJ1cXJmOHY4a2d3b280Z293MDhna2tjMGNrODA0ODh3bzQ0czhvNDhzZzg0azQw" | base64 -d -w 0)
client_secret=$(echo -n "NGRzcWZudGlldTB3Y2t3d280MGt3ODQ4Z3c0bzBjOGs0b3djODBrNGdvMGNzMGs4NDQ=" | base64 -d -w 0)

# ğŸ¯ Charger les paramÃ¨tres de configuration
oauth_url="https://sso.myfox.io/oauth/oauth/v2/token"
username="$(jq -r .somfy_protect.username /data/options.json)"
password="$(jq -r .somfy_protect.password /data/options.json)"

# ğŸ”‘ Obtenir un access_token
echo "ğŸ“¡ Obtention du token OAuth2..."
response=$(curl -s -X POST "$oauth_url" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "grant_type=password" \
    -d "client_id=$client_id" \
    -d "client_secret=$client_secret" \
    -d "username=$username" \
    -d "password=$password")

token=$(echo "$response" | jq -r .access_token)
if [ "$token" == "null" ] || [ -z "$token" ]; then
    bashio::log.error "âŒ Ã‰chec de l'authentification. VÃ©rifiez vos identifiants."
    exit 1
fi

bashio::log.info "âœ… Token obtenu avec succÃ¨s."

# ğŸ”„ RÃ©cupÃ©ration du site depuis la configuration
site_name="$(jq -r .somfy_protect.site /data/options.json)"

# ğŸ“¡ Appel API pour rÃ©cupÃ©rer la liste des sites
bashio::log.info "ğŸ” Recherche du site_id pour le site : $site_name"
sites_response=$(curl -s -X GET "https://api.myfox.io/v3/site" \
    -H "Authorization: Bearer $token")

# ğŸ›  Extraction du site_id correspondant au site_name
site_id=$(echo "$sites_response" | jq -r --arg site "$site_name" '.items[] | select(.name == $site) | .site_id')

# ğŸ›‘ VÃ©rification
if [ -z "$site_id" ] || [ "$site_id" == "null" ]; then
    bashio::log.error "âŒ Erreur : Aucun site_id trouvÃ© pour le site \"$site_name\"."
    exit 1
fi

bashio::log.info "âœ… Site ID trouvÃ© : $site_id"

# ğŸ“¡ Appel API pour rÃ©cupÃ©rer les devices du site
bashio::log.info "ğŸ” RÃ©cupÃ©ration des appareils pour le site : $site_id"
devices_response=$(curl -s -X GET "https://api.myfox.io/v3/site/$site_id/device" \
    -H "Authorization: Bearer $token")

# ğŸ›  Extraction du device_id correspondant Ã  une camÃ©ra extÃ©rieure
device_id=$(echo "$devices_response" | jq -r '.items[] | select(.device_definition.device_definition_id == "sp_outdoor_cam1") | .device_id')

# ğŸ›‘ VÃ©rification
if [ -z "$device_id" ] || [ "$device_id" == "null" ]; then
    bashio::log.error "âŒ Erreur : Aucun device_id trouvÃ© pour une camÃ©ra extÃ©rieure sur le site \"$site_name\"."
    exit 1
fi

bashio::log.info "âœ… Device ID trouvÃ© : $device_id"

# ğŸŒ URL du WebSocket
bashio::log.info "ğŸ”Œ Connexion au WebSocket..."

bashio::log.info "ğŸ”Œ Lancement du WebSocket en Python..."
export WS_URL="wss://websocket.myfox.io/events/websocket?token=$token"
python3 /usr/bin/websocket_listener.py &  # Le '&' lance le script en arriÃ¨re-plan

bashio::log.info "âœ… WebSocket lancÃ© en arriÃ¨re-plan"

# ğŸ• Pause pour s'assurer que le WebSocket est bien Ã©tabli
sleep 5

# ğŸ“¡ Demander le dÃ©marrage du flux vidÃ©o via l'API
STREAM_URL="https://api.myfox.io/v3/site/$site_id/device/$device_id/action"

bashio::log.info "ğŸ“¡ Demande de dÃ©marrage du flux vidÃ©o..."
response=$(curl -s -X POST "$STREAM_URL" \
    -H "Authorization: Bearer $token" \
    -H "Content-Type: application/json" \
    -d '{"action": "stream_start"}')

bashio::log.info "ğŸ“¡ RÃ©ponse de l'API : $response"

# ğŸš€ Attendre l'arrivÃ©e du flux vidÃ©o
timeout=90
elapsed=0
while true; do
    while [ ! -s /tmp/rtmps_url ]; do
        bashio::log.info "âŒ› En attente d'un flux RTMPS..."
        sleep 1
        elapsed=$((elapsed + 1))

        if [ $elapsed -ge $timeout ]; then
            rm /tmp/rtmps_url
            bashio::log.info "âœ…Demande de renouvellement du flux vidÃ©o /90s..."
            response=$(curl -s -X POST "$STREAM_URL" \
                -H "Authorization: Bearer $token" \
                -H "Content-Type: application/json" \
                -d '{"action": "stream_start"}')
            bashio::log.info "ğŸ“¡ RÃ©ponse de l'API : $response"
            elapsed=0
        fi
    done
    sleep 90
    elapsed=0
done &

# ğŸš€ Attendre l'arrivÃ©e du flux vidÃ©o
while [ ! -s /tmp/rtmps_url ]; do
    bashio::log.info "âŒ› En attente d'un flux RTMPS..."
    sleep 1
done

# ğŸ“¥ Lire l'URL RTMPS extraite
RTMPS_URL=$(cat /tmp/rtmps_url)
RTMPS_URL_OUT=$(jq --raw-output '.rtmps_url_output' /data/options.json)
HLS_PATH="/www/hls"

while true; do
    bashio::log.info "ğŸ¯ Flux RTMPS dÃ©tectÃ© : $RTMPS_URL"

    # ğŸ”„ Nettoyer l'ancienne session
    rm -rf "$HLS_PATH"
    mkdir -p "$HLS_PATH" && chmod -R 777 "$HLS_PATH"

    # VÃ©rifier si le port 7081 est libre
    if netstat -tulnp | grep ":9080"; then
        echo "Attention : Le port 9080 est dÃ©jÃ  utilisÃ©, vÃ©rifiez qu'il est bien libre."
    fi

    # ğŸï¸ Lancer la conversion RTMPS â†’ HLS
    # ffmpeg -i "$RTMPS_URL" \
    # -c:v libx264 -preset ultrafast -tune zerolatency -threads 4 \
    # -b:v 1000k -maxrate 1000k -bufsize 2000k \
    # -r 25 -g 50 -keyint_min 25 -sc_threshold 0 \
    # -c:a aac -b:a 128k -f hls \
    # -hls_time 10 -hls_list_size 15 -hls_flags delete_segments \
    # -hls_segment_filename "$HLS_PATH/segment_%03d.ts" \
    # "$HLS_PATH/index.m3u8" &

    # ğŸï¸ Lancer la conversion RTMPS â†’ RTSP
    ffmpeg -re -i "$RTMPS_URL" \
        -c:v copy \
        -c:a copy \
        -f rtsp rtsp://localhost:8554/live.stream &

    > /tmp/rtmps_url  # Mettre Ã  vide le fichier pour attendre un nouveau flux

    sleep 90

    # Attendre un nouveau flux vidÃ©o
    bashio::log.info "âŒ› En attente d'un nouveau flux RTMPS..."
    while [ ! -s /tmp/rtmps_url ]; do
        sleep 1
    done

    RTMPS_URL=$(cat /tmp/rtmps_url)
done

# ğŸš€ Garder le conteneur actif
exec tail -f /dev/null
